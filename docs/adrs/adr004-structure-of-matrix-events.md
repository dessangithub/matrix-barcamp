# ADR004: Structure of Matrix Events

Status: accepted

<!-- These documents have names that are short noun phrases. For example, "ADR001: Deployment on Ruby on Rails 3.0.10" or "ADR009: LDAP for Multitenant Integration" -->

## Context

<!--
This section describes the forces at play, including technological, political, social, and project local. These forces are probably in tension, and should be called out as such. The language in this section is value-neutral. It is simply describing facts. -->

The BarCamp widget assists in the creation of the agenda of a BarCamp.
It is used to collect topic submissions from participants and allows session organizers to form a timetable out of this submissions.

There are different user roles in the BarCamp platform:

1. Moderator (also session organizer):
   They create the Matrix rooms (see [ADR003][adr003]), prepare the agenda frame (tracks and time slots), and do the administrative tasks during the planning session (move topics to the grid, edit topics).
2. User (also participant):
   They participate in the BarCamp and submit topics.
   When the sessions start, they join the respective rooms and the topic submitter hosts the session.

For this to work collaboratively, the Matrix protocol should be used to store the data.
There are multiple types of data that should be accessible to every user:

1. Topic submissions that form a queue. These are created by every user.
2. The structure of the session grid defining tracks and time slots. This is managed by a moderator.
3. Topic submissions are converted to proper topics and can be edited or deleted. This is managed by a moderator.
4. Topics are assigned to a session or to the parking lot. This is managed by the moderator.
5. Each session (-> a topic that is assigned to a track) is connected with a Matrix room where the session will be hosted. This is managed by a moderator.

There are multiple other operations that should be stored in a room and/or synced across users:

- Highlight a topic for all participants to give a brief introduction.
  We expect that a moderator uses a screen share in the first iteration.
- Live editing (or moving) of a topic by the moderator.
  We expect that a moderator uses a screen share in the first iteration.
- Votes (how hot is a topic?) during the presentation of a topic.
  This is planned for the future.

We need a definition of how we want to realize these interactions and how to store the data.

## Decision

<!-- This section describes our response to these forces. It is stated in full sentences, with active voice. "We will ..." -->

We will use Matrix room events and state events for the different use cases.

### Topic Submissions

We will use a `net.nordeck.barcamp.topic_submission` room event for the topic submissions.

```yaml
type: 'net.nordeck.barcamp.topic_submission'
# the content of the submission
content:
  # the title of the submission
  title: 'Data Security in Chat Systems'
  # the description of the submission
  description: 'How secure is our communication infrastructure? …'

# the ids are generated by the protocol and will
# be used to reference it in the future
event_id: '$…'
# The author of the event, used to identifier who submitted a topic.
sender: '@…'
# Used to give submissions in the queue an order
origin_server_ts: …
room_id: '!…'
# …
```

The room event has the following properties:

1. Every participant can send the event.
2. Room events have a natural ordering based on their `origin_server_ts` field.
3. The events are only used to form the queue.
   The data is migrated into a state event as soon as it is moved into the session grid by a moderator.
4. Room events can't be updated but only be redacted or replaced.
5. Redactions are only permitted by the sender and an admin.
   Other participants can't redact room events from other users.
   We don't intend these events to ever be redacted.
6. We can control the ability to send the room event via power levels to open or close the topic submission.

### Session Grid

We will use a `net.nordeck.barcamp.session_grid` state event to store the state of the session grid and `net.nordeck.barcamp.topic` state events to store the topics:

```yaml
type: 'net.nordeck.barcamp.session_grid'
# the room id of the lobby room
state_key: '!lobby-room'
# the content of the grid
content:
  # a list of all `event_id`s of the `net.nordeck.barcamp.topic_submission`
  # room events that were converted to topics. All events that
  # are referenced here are not part of the queue anymore. They
  # also stay referenced if the topic is deleted from the grid.
  consumedTopicSubmissions:
    - $aaaaa
    - $bbbbb
    - …

  # a list of tracks
  tracks:
    - # The technical id of the track
      id: 'track-0'
      # The display name of the session
      name: 'First Track'
      # the icon of the session, a icon name from semantic-ui (e.g. from FontAwesome)
      icon: 'owl'

    # … more tracks

  # a list of time slots
  timeSlots:
    # A regular timeslot that will result in a session in each track
    - # The technical id of the time slot
      id: 'timeslot-0'
      # The type of event
      type: 'sessions'
      # The start time of the time slot as a ISO 8601 string
      startTime: '2020-01-01T10:00:00Z'
      # The end time of the time slot as a ISO 8601 string
      endTime: '2020-01-01T11:00:00Z'

    # A common event timeslot that is hosted in a single room without sessions
    - # The technical id of the time slot
      id: 'timeslot-0'
      # The type of event
      type: 'common-event'
      # The start time of the time slot as a ISO 8601 string
      startTime: '2020-01-01T10:00:00Z'
      # The end time of the time slot as a ISO 8601 string
      endTime: '2020-01-01T11:00:00Z'
      # The summary of the common event
      summary: 'Coffee Break'
      # The icon of the common event, a icon name from semantic-ui (e.g. from FontAwesome)
      icon: 'coffee'

    # … more time slots

  # a list of sessions
  sessions:
    - # The ID of the track
      trackId: 'track-0'
      # The ID of the time slot
      timeSlotId: 'timeslot-0'
      # The state key of the topic in the session
      topicId: '$…'

    # … more sessions

  # a list of topics that are in the parking lot
  parkingLots:
    - # The state key of the topic in the session
      topicId: '$…'

    # … more parking lot topics

room_id: '!…'
event_id: '$…'
origin_server_ts: …
# …
```

```yaml
type: 'net.nordeck.barcamp.topic'
# The ID (derived from the event_id)
state_key: '$aaaaa'
# the content of the topic
content:
  # The title
  title: 'Data Security in Chat Systems'
  # The description
  description: 'How secure is our communication infrastructure? …'
  # The authors
  authors:
    # defaults to `sender` of the submission
    - id: '@primary-author:matrix.to'
    # multiple authors could be added later
    - id: '@secondary-author:matrix.to'
  # (optional) if true, the topic has a visual marker to tell that it should not be moved
  pinned: true

room_id: '!…'
event_id: '$…'
origin_server_ts: …
# …
```

The state event has the following properties:

1. State events can only be created or updated by moderators.
2. Data that require internal consistency and atomicity are located in a single state event.
   We can't guarantee that all operations are saved but we can guarantee that the state will always be consistent.
3. The id of an author references a user in the room.
4. All topic submission room events that are referenced in the `consumedTopicSubmissions` field are no longer in the topic queue.
5. The `state_key` will link to the lobby room that created the event.
   This will be useful in combination with the room structure ([ADR003][adr003]) and the storage location ([ADR005][adr005]) so other rooms know where to find the lobby.
   This also potentially allows to have different session grids for different days in a single space in the future.

Advantages:

1. Moving topics between sessions can be done atomically.
2. Deleting tracks and time slots can be done atomically.
3. Edit operations on one topic don't affect other topics.

Disadvantages:

1. Parallel edit operations of the grid could potentially conflict with each other.
   > - Track / Time Slot props are not saved.
   > - Topic assignments to a session or the parking lot might not be saved.
   > - A topic stays in the topic queue.
2. Parallel edit operations of the same topic could potentially conflict.
3. Adding a submission to the grid is no atomic operation because it needs two operations in the same events.
   The widget should take care that the state event for the topic exists before adding the reference to the session grid.
4. The widget needs to keep track of multiple state events.

> Only moderators can edit the grid and we expect around 1-5 moderators.
>
> The grid will be prepared before the event so it will primarily affect operations around topics.
> Due to the internal integrity of the event, this shouldn't lead to lost topics.

#### Alternatives

##### Use a single state event

Include the topics in the `net.nordeck.barcamp.session_grid` event:

```diff
  type: 'net.nordeck.barcamp.session_grid'
  # the room id of the lobby room
  state_key: '!lobby-room'
  # the content of the grid
  content:
    # …

    # a list of sessions
    sessions:
      - # The ID of the track
        trackId: 'track-0'
        # The ID of the time slot
        timeSlotId: 'timeslot-0'
-       # The state key of the topic in the session
-       topicId: '$…'
+       # The topic in the session
+       topic:
+         # The ID (derived from the event_id)
+         id: '$aaaaa'
+         # The title
+         title: 'Data Security in Chat Systems'
+         # The description
+         description: 'How secure is our communication infrastructure? …'
+         # The authors
+         authors:
+           # defaults to `sender` of the submission
+           - id: '@primary-author:matrix.to'
+           # multiple authors could be added later
+           - id: '@secondary-author:matrix.to'
+         # (optional) if true, the topic has a visual marker to tell that it should not be moved
+         pinned: true

    # a list of topics that are in the parking lot
    parkingLots:
      -
-       # The state key of the topic in the session
-       topicId: '$…'
+       # The topic in the session
+       topic:
+         # The ID (derived from the event_id)
+         id: '$aaaaa'
+         # The title
+         title: 'Data Security in Chat Systems'
+         # The description
+         description: 'How secure is our communication infrastructure? …'
+         # The authors
+         authors:
+           # defaults to `sender` of the submission
+           - id: '@primary-author:matrix.to'
+           # multiple authors could be added later
+           - id: '@secondary-author:matrix.to'
+         # (optional) if true, the topic has a visual marker to tell that it should not be moved
+         pinned: true

  # …
```

Advantages:

1. The widget only needs to read a single state event.

Disadvantages:

1. Edit operations in the topics can conflict with grid operations and vice versa.
   > - Updates to a topic are not saved because a unrelated operation was done.

##### Use a individual state events for everything

There could be state events for every track and time slot.

Advantages:

1. Parallel edit operations on topics are conflict free.
2. Parallel edit operations on tracks and time slots might be conflict free.
3. Every event could require different power levels.

Disadvantages:

1. Changes in the time or duration of a time slot are not atomic because each event must be edited separately.
2. We need a way to specify the order of tracks.
3. Deletions of a track or session could lead to inconsistent references.

> This is only a shallow investigation of this option.
> This approach is lacking an option for integrity in between time slots so we won't consider it.

### Matrix Room Mapping

```yaml
type: 'net.nordeck.barcamp.linked_room'
# the id of the room
state_key: '!room'
# the content of the room
content:
  # the state key of the session grid that holds the topic
  sessionGridId: '<state-key>'
  # the ID of the topic that is assigned to this room
  topicId: '$topic-id'

room_id: '!…'
event_id: '$…'
origin_server_ts: …
# …
```

The state event has the following properties:

1. State events can only be created or updated by moderators.
2. There is a single state event for each room ⟷ topic connection.
   Topics should be not be used twice.
   The UI will use the event with the lowest `origin_server_ts` in this rare case.
3. If a topic is deleted, the stale mapping event is tolerable.
4. Having the room id as state key makes it easy to recognize the type of room.

#### Alternatives

We could also add the room as part of the original event.
However, the chosen approach has a few advantages:

- The mapping is independent from the grid itself.
  This comes in handy in the future if we move the creation process to a bot (see [ADR003][adr003]).
  Then human users and automated users don't work on the same events.

## Consequences

<!-- This section describes the resulting context, after applying the decision. All consequences should be listed here, not just the "positive" ones. A particular decision may have positive, negative, and neutral consequences, but all of them affect the team and project in the future. -->

### Event Definitions

We create the definitions of the new events and store the events according to [ADR005][adr005].
We use the events to provide the state to the widget.

By default, the session grid is empty.
Currently, we don't support an empty state in the BarCamp widget.
We will add a welcome screen that assists the moderator with the initialization of the space.

### Power Levels

The defaults of the Matrix protocol permit everyone to send room events (i.e. submit topics) and limit moderators to change state events (i.e. grid and room mappings).
This fits to our expected model but can also be customized if needed.

### Event Updates

If multiple users update the grid at the same time, there is a potential for conflicts.
The probability is primarily determined by the delay between sending an event and receiving it:
If all moderators are located on the same home server, there should only be a small delay.
This reduces the window for conflict opportunities.

The widget should prefer to work with “change tasks” and apply them to the most fresh copy of an event in their local cache (examples: delete track X, update the duration of slot X to Y, update title of topic X to Y).

### Capabilities

The widget must request read/write permissions for the three events discussed in this ADR for the rooms discussed in [ADR005][adr005].
In addition, the widget needs read access to the `m.room.power_levels` event to determine the role of the user and the `m.room.member` event to show the avatar and display name of a user.

### Topics Queue

The topics queue shows the topic submission in the order defined by `origin_server_ts`.
When a topic is removed from the queue, it is added to the `net.nordeck.barcamp.session_grid` event.

Read the room event:

```yaml
type: 'net.nordeck.barcamp.topic_submission'
event_id: '$001'
sender: '@author'
origin_server_ts: 111
# …
content:
  title: 'Data Security in Chat Systems'
  description: 'How secure is our communication infrastructure? …'
```

Create the topic event:

```yaml
type: 'net.nordeck.barcamp.topic'
state_key: '$001'
# …
content:
  title: 'Data Security in Chat Systems'
  description: 'How secure is our communication infrastructure? …'
  authors:
    - id: '@author'
```

Add it to the session grid:

```diff
  type: 'net.nordeck.barcamp.session_grid'
  state_key: '…'
  # …
  content:
    consumedTopicSubmissions:
+     - $001
      - …

    tracks: []
    timeSlots:  []
    sessions: []
    parkingLots:
+     - topicId: '$001'
```

Topic IDs that are part of the `consumedTopicSubmissions` will be ignored when forming the queue.

<!-- This template is taken from a blog post by Michael Nygard http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions -->

[adr003]: ./adr003-space-structure.md
[adr005]: ./adr005-event-storage-location.md
